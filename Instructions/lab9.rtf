{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c6667\c6667\c6667;\cssrgb\c100000\c100000\c100000;}
\margl1440\margr1440\vieww14860\viewh22540\viewkind0
\deftab720
\pard\pardeftab720\sl240\sa200\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For the Chapter 9 lab, you\'a0add to a working program. Much of the work is reading and understanding the code that is provided. It contains one working sort algorithm and one working search algorithm. Your job is to add two new sort algorithms and one new search algorithm. When complete, the program implements and tests three different sort\'a0algorithms and two different search algorithms. (26 points max if you add one sort and one search. 30 points max if you add two new sorts and one new search.)\
The choice of new algorithms is yours. The textbook provides algorithms and explanations for linear search and binary search; and\'a0source code and explanations for bubble sort and selection sort.\'a0These are\'a0commonly used\'a0algorithms for\'a0searching and sorting.\
Note: The starting program is provided on the assignment link. Selection sort and linear search are already coded and tested. You have to add two more sorts and one more search algorithm. In the code you provide, use variable names (often very cryptic in textbooks) in your own terms, so the algorithm is easier to understand. Also provide good comments.\cb1 \uc0\u8232 \cb3 \'a0\'a0\cb1 \uc0\u8232 \cb3 When you implement these algorithms, use your own variable names and comments, which reflect your own personal understanding of how these algorithms work. You can use the textbook code at first, but modify the names, and add comments, to show your understanding of what it is doing. Test your code to verify it works by sorting a small array properly.\cb1 \uc0\u8232 \cb3 \'a0\'a0\cb1 \uc0\u8232 \cb3 Next,\'a0measure the performance of your algorithms and find out which is best. Performance measuring code is provided. To measure the performance, the program gets the time before and after your algorithm runs and subtracts the stop time from the start time to get the duration, in milliseconds, of your algorithm. Example:
\fs20 \
\pard\pardeftab720\sl300\sa200\partightenfactor0

\f1\fs26 \cf2 \'a0 typedef unsigned int uint\cb1 \uc0\u8232 \cb3 \'a0 uint startTime, stopTime, duration;\cb1 \uc0\u8232 \cb3 \'a0 startTime = clock();\cb1 \uc0\u8232 \cb3 \'a0 algorithm(parameter1, parameter2, parameter3, etc);\'a0 // search\'a0or sort algorithm\cb1 \uc0\u8232 \cb3 \'a0 stopTime = clock();\cb1 \uc0\u8232 \cb3 \'a0 duration = stopTime - startTime;\cb1 \uc0\u8232 \cb3 \'a0 cout << "algorithm took: " << duration << "milliseconds."
\f0\fs20 \'a0\'a0\
\pard\pardeftab720\sl240\sa200\partightenfactor0

\fs24 \cf2 For small data sizes, the time will be 0 milliseconds. To get a useful duration, it works better if it runs for at least 1/4 second (250 milliseconds). Two ways to get an algorithm to run longer: 1) increase the data size; 2) place a loop around the algorithm, so it runs many times. For example, perform a search 1000 times in a loop, and divide the duration by 1000.0 to get the milliseconds for one iteration.\
Performance testing code is provided. It will try five different array sizes. Try to keep the maximum execution time to at most 10 seconds. Arrays of size: 5000, 10000, 20000, 30000, 40000, up to 100000 may work. Include the performance results of your experimentation here. Example (for each entry, there is some number, in milliseconds):
\fs20 \cb1 \uc0\u8232 \u8232 
\f1\fs26 \cb3 \'a0\'a0\'a0 Algorithm\'a0\'a0\'a0 1000\'a0 10000\'a0 20000\'a0 30000\'a0 40000\'a0\'a0 50000\'a0 (Array size)\cb1 \uc0\u8232 \cb3 \'a0\'a0\'a0 ----------\'a0 -----\'a0\'a0-----\'a0\'a0-----\'a0\'a0-----\'a0\'a0-----\'a0 ------\cb1 \uc0\u8232 \cb3 \'a0\'a0\'a0 sort1\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 x\'a0\'a0\'a0\'a0\'a0xx\'a0\'a0\'a0 xxx\'a0\'a0 xxxx\'a0\'a0xxxxx\'a0 xxxxxx\cb1 \uc0\u8232 \cb3 \'a0\'a0\'a0 sort2\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 y\'a0\'a0\'a0\'a0\'a0yy\'a0\'a0\'a0\'a0yyy\'a0\'a0\'a0yyyy\'a0\'a0yyyyy\'a0 yyyyyy\cb1 \uc0\u8232 \cb3 \'a0\'a0\'a0 sort3\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0z\'a0\'a0\'a0\'a0\'a0zz\'a0\'a0 \'a0zzz\'a0\'a0\'a0zzzz\'a0\'a0zzzzz\'a0 yyyyyy
\f0\fs20 \cb1 \uc0\u8232 
\f1\fs26 \cb3 \'a0\'a0\'a0 search1\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 m\'a0\'a0\'a0\'a0 mm\'a0\'a0\'a0 mmm\'a0\'a0 mmmm\'a0 mmmmm\'a0 mmmmmm\cb1 \uc0\u8232 \cb3 \'a0\'a0\'a0 search2\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 n\'a0\'a0\'a0\'a0\'a0nn\'a0\'a0\'a0 nnn\'a0\'a0\'a0nnnn\'a0\'a0nnnnn\'a0 nnnnnn\
\pard\pardeftab720\sl240\sa200\partightenfactor0

\f0\fs20 \cf2 \cb1 \uc0\u8232 
\fs24 \cb3 Observe: As the size of the array increases, how does the duration increase?\cb1 \uc0\u8232 \cb3 \'a0\'a0\cb1 \uc0\u8232 \cb3 Note: Code for automating the performance testing of the algorithms is included. Read the code to understand how to performance test your own search and sort algorithms. Very short run-times (fast algorithms, small data) may register as 0 time, which is under 1 millisecond (1/1000th of a second).\
When submitting this lab, change the file name from:: DDHH_L9_Lastname to: <course designator>_L9_<your last name>.cpp
\fs20 \
}